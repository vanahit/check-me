{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar IndexedFilter_1 = require(\"./IndexedFilter\");\n\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\n\nvar Node_1 = require(\"../../../core/snap/Node\");\n\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n/**\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\n *\n * @constructor\n * @implements {NodeFilter}\n */\n\n\nvar RangedFilter =\n/** @class */\nfunction () {\n  /**\n   * @param {!QueryParams} params\n   */\n  function RangedFilter(params) {\n    this.indexedFilter_ = new IndexedFilter_1.IndexedFilter(params.getIndex());\n    this.index_ = params.getIndex();\n    this.startPost_ = RangedFilter.getStartPost_(params);\n    this.endPost_ = RangedFilter.getEndPost_(params);\n  }\n  /**\n   * @return {!NamedNode}\n   */\n\n\n  RangedFilter.prototype.getStartPost = function () {\n    return this.startPost_;\n  };\n  /**\n   * @return {!NamedNode}\n   */\n\n\n  RangedFilter.prototype.getEndPost = function () {\n    return this.endPost_;\n  };\n  /**\n   * @param {!NamedNode} node\n   * @return {boolean}\n   */\n\n\n  RangedFilter.prototype.matches = function (node) {\n    return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    if (!this.matches(new Node_1.NamedNode(key, newChild))) {\n      newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n\n    return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (newSnap.isLeafNode()) {\n      // Make sure we have a children node with the correct index, not a leaf node;\n      newSnap = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    }\n\n    var filtered = newSnap.withIndex(this.index_); // Don't support priorities on queries\n\n    filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n    var self = this;\n    newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      if (!self.matches(new Node_1.NamedNode(key, childNode))) {\n        filtered = filtered.updateImmediateChild(key, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n      }\n    });\n    return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    // Don't support priorities on queries\n    return oldSnap;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.filtersNodes = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.getIndexedFilter = function () {\n    return this.indexedFilter_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RangedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n\n\n  RangedFilter.getStartPost_ = function (params) {\n    if (params.hasStart()) {\n      var startName = params.getIndexStartName();\n      return params.getIndex().makePost(params.getIndexStartValue(), startName);\n    } else {\n      return params.getIndex().minPost();\n    }\n  };\n  /**\n   * @param {!QueryParams} params\n   * @return {!NamedNode}\n   * @private\n   */\n\n\n  RangedFilter.getEndPost_ = function (params) {\n    if (params.hasEnd()) {\n      var endName = params.getIndexEndName();\n      return params.getIndex().makePost(params.getIndexEndValue(), endName);\n    } else {\n      return params.getIndex().maxPost();\n    }\n  };\n\n  return RangedFilter;\n}();\n\nexports.RangedFilter = RangedFilter;","map":null,"metadata":{},"sourceType":"script"}