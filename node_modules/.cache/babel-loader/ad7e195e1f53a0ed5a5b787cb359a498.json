{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"../util/Path\");\n\nvar Operation_1 = require(\"./Operation\");\n\nvar AckUserWrite =\n/** @class */\nfunction () {\n  /**\n   *\n   * @param {!Path} path\n   * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.\n   * @param {!boolean} revert\n   */\n  function AckUserWrite(\n  /**@inheritDoc */\n  path,\n  /**@inheritDoc */\n  affectedTree,\n  /**@inheritDoc */\n  revert) {\n    this.path = path;\n    this.affectedTree = affectedTree;\n    this.revert = revert;\n    /** @inheritDoc */\n\n    this.type = Operation_1.OperationType.ACK_USER_WRITE;\n    /** @inheritDoc */\n\n    this.source = Operation_1.OperationSource.User;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  AckUserWrite.prototype.operationForChild = function (childName) {\n    if (!this.path.isEmpty()) {\n      util_1.assert(this.path.getFront() === childName, 'operationForChild called for unrelated child.');\n      return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);\n    } else if (this.affectedTree.value != null) {\n      util_1.assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.'); // All child locations are affected as well; just return same operation.\n\n      return this;\n    } else {\n      var childTree = this.affectedTree.subtree(new Path_1.Path(childName));\n      return new AckUserWrite(Path_1.Path.Empty, childTree, this.revert);\n    }\n  };\n\n  return AckUserWrite;\n}();\n\nexports.AckUserWrite = AckUserWrite;","map":null,"metadata":{},"sourceType":"script"}