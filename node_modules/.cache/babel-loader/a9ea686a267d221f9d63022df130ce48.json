{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Repo_1 = require(\"./Repo\");\n\nvar util_2 = require(\"./util/util\");\n\nvar parser_1 = require(\"./util/libs/parser\");\n\nvar validation_1 = require(\"./util/validation\");\n\nrequire(\"./Repo_transaction\");\n/** @const {string} */\n\n\nvar DATABASE_URL_OPTION = 'databaseURL';\n\nvar _staticInstance;\n/**\n * Creates and caches Repo instances.\n */\n\n\nvar RepoManager =\n/** @class */\nfunction () {\n  function RepoManager() {\n    /**\n     * @private {!Object.<string, Object<string, !fb.core.Repo>>}\n     */\n    this.repos_ = {};\n    /**\n     * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).\n     * @private {boolean}\n     */\n\n    this.useRestClient_ = false;\n  }\n\n  RepoManager.getInstance = function () {\n    if (!_staticInstance) {\n      _staticInstance = new RepoManager();\n    }\n\n    return _staticInstance;\n  }; // TODO(koss): Remove these functions unless used in tests?\n\n\n  RepoManager.prototype.interrupt = function () {\n    for (var appName in this.repos_) {\n      for (var dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].interrupt();\n      }\n    }\n  };\n\n  RepoManager.prototype.resume = function () {\n    for (var appName in this.repos_) {\n      for (var dbUrl in this.repos_[appName]) {\n        this.repos_[appName][dbUrl].resume();\n      }\n    }\n  };\n  /**\n   * This function should only ever be called to CREATE a new database instance.\n   *\n   * @param {!FirebaseApp} app\n   * @return {!Database}\n   */\n\n\n  RepoManager.prototype.databaseFromApp = function (app, url) {\n    var dbUrl = url || app.options[DATABASE_URL_OPTION];\n\n    if (dbUrl === undefined) {\n      util_2.fatal(\"Can't determine Firebase Database URL.  Be sure to include \" + DATABASE_URL_OPTION + ' option when calling firebase.intializeApp().');\n    }\n\n    var parsedUrl = parser_1.parseRepoInfo(dbUrl);\n    var repoInfo = parsedUrl.repoInfo;\n    validation_1.validateUrl('Invalid Firebase Database URL', 1, parsedUrl);\n\n    if (!parsedUrl.path.isEmpty()) {\n      util_2.fatal('Database URL must point to the root of a Firebase Database ' + '(not including a child path).');\n    }\n\n    var repo = this.createRepo(repoInfo, app);\n    return repo.database;\n  };\n  /**\n   * Remove the repo and make sure it is disconnected.\n   *\n   * @param {!Repo} repo\n   */\n\n\n  RepoManager.prototype.deleteRepo = function (repo) {\n    var appRepos = util_1.safeGet(this.repos_, repo.app.name); // This should never happen...\n\n    if (!appRepos || util_1.safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {\n      util_2.fatal(\"Database \" + repo.app.name + \"(\" + repo.repoInfo_ + \") has already been deleted.\");\n    }\n\n    repo.interrupt();\n    delete appRepos[repo.repoInfo_.toURLString()];\n  };\n  /**\n   * Ensures a repo doesn't already exist and then creates one using the\n   * provided app.\n   *\n   * @param {!RepoInfo} repoInfo The metadata about the Repo\n   * @param {!FirebaseApp} app\n   * @return {!Repo} The Repo object for the specified server / repoName.\n   */\n\n\n  RepoManager.prototype.createRepo = function (repoInfo, app) {\n    var appRepos = util_1.safeGet(this.repos_, app.name);\n\n    if (!appRepos) {\n      appRepos = {};\n      this.repos_[app.name] = appRepos;\n    }\n\n    var repo = util_1.safeGet(appRepos, repoInfo.toURLString());\n\n    if (repo) {\n      util_2.fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');\n    }\n\n    repo = new Repo_1.Repo(repoInfo, this.useRestClient_, app);\n    appRepos[repoInfo.toURLString()] = repo;\n    return repo;\n  };\n  /**\n   * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\n   * @param {boolean} forceRestClient\n   */\n\n\n  RepoManager.prototype.forceRestClient = function (forceRestClient) {\n    this.useRestClient_ = forceRestClient;\n  };\n\n  return RepoManager;\n}();\n\nexports.RepoManager = RepoManager;","map":null,"metadata":{},"sourceType":"script"}