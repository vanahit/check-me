{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\nvar FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';\nvar FCM_TOKEN_DETAILS_DB_VERSION = 1;\n\nvar TokenManager =\n/** @class */\nfunction () {\n  function TokenManager() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n    this.openDbPromise_ = null;\n  }\n  /**\n   * Get the indexedDB as a promsie.\n   * @private\n   * @return {Promise<IDBDatabase>} The IndexedDB database\n   */\n\n\n  TokenManager.prototype.openDatabase_ = function () {\n    if (this.openDbPromise_) {\n      return this.openDbPromise_;\n    }\n\n    this.openDbPromise_ = new Promise(function (resolve, reject) {\n      var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);\n\n      request.onerror = function (event) {\n        reject(event.target.error);\n      };\n\n      request.onsuccess = function (event) {\n        resolve(event.target.result);\n      };\n\n      request.onupgradeneeded = function (event) {\n        var db = event.target.result;\n        var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {\n          keyPath: 'swScope'\n        }); // Make sure the sender ID can be searched\n\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n        objectStore.createIndex('fcmToken', 'fcmToken', {\n          unique: true\n        });\n      };\n    });\n    return this.openDbPromise_;\n  };\n  /**\n   * Close the currently open database.\n   * @return {Promise<?>} Returns the result of the promise chain.\n   */\n\n\n  TokenManager.prototype.closeDatabase = function () {\n    var _this = this;\n\n    if (this.openDbPromise_) {\n      return this.openDbPromise_.then(function (db) {\n        db.close();\n        _this.openDbPromise_ = null;\n      });\n    }\n\n    return Promise.resolve();\n  };\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   * @public\n   * @param {string} fcmToken\n   * @return {Promise<Object>} The details associated with that token.\n   */\n\n\n  TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var index = objectStore.index('fcmToken');\n        var request = index.get(fcmToken);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var scopeRequest = objectStore.get(swScope);\n\n        scopeRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        scopeRequest.onsuccess = function (event) {\n          resolve(event.target.result);\n        };\n      });\n    });\n  };\n\n  TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var senderIdTokens = [];\n        var cursorRequest = objectStore.openCursor();\n\n        cursorRequest.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        cursorRequest.onsuccess = function (event) {\n          var cursor = event.target.result;\n\n          if (cursor) {\n            if (cursor.value['fcmSenderId'] === senderId) {\n              senderIdTokens.push(cursor.value);\n            }\n\n            cursor.continue();\n          } else {\n            resolve(senderIdTokens);\n          }\n        };\n      });\n    });\n  };\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {string=} pushSet If defined this will swap the subscription for\n   * matching FCM token.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n\n\n  TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {\n    var _this = this;\n\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n\n    if (pushSet) {\n      fcmSubscribeBody += \"&pushSet=\" + pushSet;\n    }\n\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n      return response.json();\n    }).then(function (response) {\n      var fcmTokenResponse = response;\n\n      if (fcmTokenResponse['error']) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n          message: message\n        });\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        token: fcmTokenResponse['token'],\n        pushSet: fcmTokenResponse['pushSet']\n      };\n    });\n  };\n  /**\n   * Checks the that fields in the PushSubscription are equivalent to the\n   * details stores in the masterTokenDetails.\n   * @private\n   * @param  {PushSubscription} subscription The push subscription we expect\n   * the master token to match.\n   * @param  {Object}  masterTokenDetails The saved details we wish to compare\n   * with the PushSubscription\n   * @return {boolean} true if the subscription and token details are\n   * equivalent.\n   */\n\n\n  TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return subscription.endpoint === masterTokenDetails['endpoint'] && arrayBufferToBase64(subscription['getKey']('auth')) === masterTokenDetails['auth'] && arrayBufferToBase64(subscription['getKey']('p256dh')) === masterTokenDetails['p256dh'];\n  };\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @private\n   * @param  {string} senderId The 'messagingSenderId' used for this project\n   * @param  {ServiceWorkerRegistration} swRegistration The service worker\n   * used to subscribe the user for web push\n   * @param  {PushSubscription} subscription The push subscription passed to\n   * FCM for the current token.\n   * @param  {string} fcmToken The FCM token currently used on this\n   * device.\n   * @param  {string} fcmPushSet The FCM push tied to the fcm token.\n   * @return {Promise<void>}\n   */\n\n\n  TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {\n    var details = {\n      swScope: swRegistration.scope,\n      endpoint: subscription.endpoint,\n      auth: arrayBufferToBase64(subscription['getKey']('auth')),\n      p256dh: arrayBufferToBase64(subscription['getKey']('p256dh')),\n      fcmToken: fcmToken,\n      fcmPushSet: fcmPushSet,\n      fcmSenderId: senderId\n    };\n    return this.openDatabase_().then(function (db) {\n      return new Promise(function (resolve, reject) {\n        var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n        var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n        var request = objectStore.put(details);\n\n        request.onerror = function (event) {\n          reject(event.target.error);\n        };\n\n        request.onsuccess = function (event) {\n          resolve();\n        };\n      });\n    });\n  };\n  /**\n   * Returns the saved FCM Token if one is available and still valid,\n   * otherwise `null` is returned.\n   * @param {string} senderId This should be the sender ID associated with the\n   * FCM Token being retrieved.\n   * @param {ServiceWorkerRegistration} swRegistration Registration to be used\n   * to subscribe the user to push.\n   * @return {Promise<string> | Promise} Returns the saved FCM Token if\n   * avilable and valid.\n   * @export\n   */\n\n\n  TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    }\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    return this.getAllTokenDetailsForSenderId_(senderId).then(function (allTokenDetails) {\n      if (allTokenDetails.length === 0) {\n        return;\n      }\n\n      var index = allTokenDetails.findIndex(function (tokenDetails) {\n        return swRegistration.scope === tokenDetails['swScope'] && senderId === tokenDetails['fcmSenderId'];\n      });\n\n      if (index === -1) {\n        return;\n      }\n\n      return allTokenDetails[index];\n    }).then(function (tokenDetails) {\n      if (!tokenDetails) {\n        return;\n      }\n\n      return swRegistration.pushManager.getSubscription().catch(function (err) {\n        throw _this.errorFactory_.create(Errors.codes.GET_SUBSCRIPTION_FAILED);\n      }).then(function (subscription) {\n        if (subscription && _this.isSameSubscription_(subscription, tokenDetails)) {\n          return tokenDetails['fcmToken'];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a new FCM token.\n   */\n\n\n  TokenManager.prototype.createToken = function (senderId, swRegistration) {\n    var _this = this;\n\n    if (typeof senderId !== 'string' || senderId.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.BAD_SENDER_ID));\n    }\n\n    if (!(swRegistration instanceof ServiceWorkerRegistration)) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.SW_REGISTRATION_EXPECTED));\n    } // Check for existing subscription first\n\n\n    var subscription;\n    var fcmTokenDetails;\n    return swRegistration.pushManager.getSubscription().then(function (subscription) {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe(FCMDetails.SUBSCRIPTION_OPTIONS);\n    }).then(function (sub) {\n      subscription = sub;\n      return _this.subscribeToFCM(senderId, subscription);\n    }).then(function (tokenDetails) {\n      fcmTokenDetails = tokenDetails;\n      return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);\n    }).then(function () {\n      return fcmTokenDetails['token'];\n    });\n  };\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   * @param {string} token Token to be deleted\n   * @return {Promise<Object>} Resolves once the FCM token details have been\n   * deleted and returns the deleted details.\n   */\n\n\n  TokenManager.prototype.deleteToken = function (token) {\n    var _this = this;\n\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(this.errorFactory_.create(Errors.codes.INVALID_DELETE_TOKEN));\n    }\n\n    return this.getTokenDetailsFromToken(token).then(function (details) {\n      if (!details) {\n        throw _this.errorFactory_.create(Errors.codes.DELETE_TOKEN_NOT_FOUND);\n      }\n\n      return _this.openDatabase_().then(function (db) {\n        return new Promise(function (resolve, reject) {\n          var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');\n          var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);\n          var request = objectStore.delete(details['swScope']);\n\n          request.onerror = function (event) {\n            reject(event.target.error);\n          };\n\n          request.onsuccess = function (event) {\n            if (event.target.result === 0) {\n              reject(_this.errorFactory_.create(Errors.codes.FAILED_TO_DELETE_TOKEN));\n              return;\n            }\n\n            resolve(details);\n          };\n        });\n      });\n    });\n  };\n\n  return TokenManager;\n}();\n\nexport default TokenManager;","map":null,"metadata":{},"sourceType":"module"}