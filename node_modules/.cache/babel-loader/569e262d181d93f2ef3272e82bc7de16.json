{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RepoInfo_1 = require(\"../core/RepoInfo\");\n\nvar PersistentConnection_1 = require(\"../core/PersistentConnection\");\n\nvar RepoManager_1 = require(\"../core/RepoManager\");\n\nvar Connection_1 = require(\"../realtime/Connection\");\n\nexports.DataConnection = PersistentConnection_1.PersistentConnection;\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n\nPersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\n  this.sendRequest('q', {\n    p: pathString\n  }, onComplete);\n};\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n\n\nPersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {\n  this.sendRequest('echo', {\n    d: data\n  }, onEcho);\n}; // RealTimeConnection properties that we use in tests.\n\n\nexports.RealTimeConnection = Connection_1.Connection;\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\n\nexports.hijackHash = function (newHash) {\n  var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;\n\n  PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n\n  return function () {\n    PersistentConnection_1.PersistentConnection.prototype.put = oldPut;\n  };\n};\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\n\n\nexports.ConnectionTarget = RepoInfo_1.RepoInfo;\n/**\n * @param {!Query} query\n * @return {!string}\n */\n\nexports.queryIdentifier = function (query) {\n  return query.queryIdentifier();\n};\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\n\n\nexports.listens = function (firebaseRef) {\n  return firebaseRef.repo.persistentConnection_.listens_;\n};\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\n\n\nexports.forceRestClient = function (forceRestClient) {\n  RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);\n};","map":null,"metadata":{},"sourceType":"script"}